<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>СИНТЕЗ - Хімічна Стратегія</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        .scrollbar-hide::-webkit-scrollbar {
            display: none;
        }
        .scrollbar-hide {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            background-color: #f3f4f6;
        }
        /* Анімація для повідомлення про перевантаження */
        @keyframes pulse-red {
            0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            50% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
        }
        .animate-pulse-red {
            animation: pulse-red 2s infinite;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useMemo, useRef } from 'https://esm.sh/react@18.2.0';
        import { createRoot } from 'https://esm.sh/react-dom@18.2.0/client';
        
        // Імпорт Firebase (залишаємо тільки одну версію - 10.8.0)
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
        import { 
            getFirestore, collection, doc, setDoc, onSnapshot, updateDoc, 
            arrayUnion, runTransaction 
        } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";
        import { 
            getAuth, signInAnonymously, onAuthStateChanged 
        } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";
        
        import { 
            Atom, FlaskConical, Users, Copy, Check, AlertTriangle, 
            ArrowRightLeft, Play, RotateCcw, Crown, LogOut, Loader2, X, RefreshCcw, LayoutGrid, Menu, History, Trash2
        } from 'https://esm.sh/lucide-react@0.263.1';

        // ==========================================
        // НАЛАШТУВАННЯ FIREBASE (ВАШІ ДАНІ)
        // ==========================================
        const firebaseConfig = {
            apiKey: "AIzaSyAEownlzJ0AqrnAku7Cw208N2DRLQHdD6Y",
            authDomain: "synthesis-game-f9684.firebaseapp.com",
            projectId: "synthesis-game-f9684",
            storageBucket: "synthesis-game-f9684.firebasestorage.app",
            messagingSenderId: "257683012244",
            appId: "1:257683012244:web:c7aee7e27c929ceb5b9281"
        };
        
        // Ініціалізація (робимо це один раз)
        let app, auth, db;
        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            console.log("Firebase initialized successfully");
        } catch (e) {
            console.error("Firebase Error", e);
        }

        const appId = 'synthesis-game';

        // --- ДАНІ ГРИ ---

        const ELEMENT_DISTRIBUTION = {
            'H': 24, 'O': 34, 'C': 12, 'Na': 10, 'Cl': 7, 'Ca': 8, 'N': 7, 'S': 6, 'Si': 4
        };

        const ELEMENTS = {
            'H':  { m: 1,  name: 'Гідроген', color: 'bg-blue-100 text-blue-900 border-blue-300' },
            'O':  { m: 16, name: 'Оксиген',  color: 'bg-red-100 text-red-900 border-red-300' },
            'C':  { m: 12, name: 'Карбон',   color: 'bg-gray-200 text-gray-900 border-gray-400' },
            'N':  { m: 14, name: 'Нітроген', color: 'bg-indigo-100 text-indigo-900 border-indigo-300' },
            'Na': { m: 23, name: 'Натрій',   color: 'bg-purple-100 text-purple-900 border-purple-300' },
            'Cl': { m: 35.5, name: 'Хлор',   color: 'bg-green-100 text-green-900 border-green-300' },
            'Ca': { m: 40, name: 'Кальцій',  color: 'bg-orange-100 text-orange-900 border-orange-300' },
            'S':  { m: 32, name: 'Сульфур',  color: 'bg-yellow-100 text-yellow-900 border-yellow-400' },
            'Si': { m: 28, name: 'Силіцій',  color: 'bg-stone-200 text-stone-800 border-stone-400' },
        };

        const MOLECULES_LIST = [
            // Прості
            { id: 'h2o',     f: 'H₂O',      name: 'Вода',              vp: 3, count: 6, req: { 'H': 2, 'O': 1 } },
            { id: 'co',      f: 'CO',       name: 'Чадний газ',        vp: 4, count: 4, req: { 'C': 1, 'O': 1 } },
            { id: 'hcl',     f: 'HCl',      name: 'Хлоридна кислота',  vp: 6, count: 3, req: { 'H': 1, 'Cl': 1 } },
            { id: 'cao',     f: 'CaO',      name: 'Негашене вапно',    vp: 4, count: 3, req: { 'Ca': 1, 'O': 1 } },
            // Середні
            { id: 'co2',     f: 'CO₂',      name: 'Вуглекислий газ',   vp: 5, count: 5, req: { 'C': 1, 'O': 2 } },
            { id: 'nacl',    f: 'NaCl',     name: 'Кухонна сіль',      vp: 8, count: 4, req: { 'Na': 1, 'Cl': 1 } },
            { id: 'naoh',    f: 'NaOH',     name: 'Каустична сода',    vp: 5, count: 3, req: { 'Na': 1, 'O': 1, 'H': 1 } },
            { id: 'nh3',     f: 'NH₃',      name: 'Аміак',             vp: 8, count: 2, req: { 'N': 1, 'H': 3 } },
            { id: 'h2o2',    f: 'H₂O₂',     name: 'Перекис водню',     vp: 4, count: 2, req: { 'H': 2, 'O': 2 } },
            { id: 'so2',     f: 'SO₂',      name: 'Сірчистий газ',     vp: 4, count: 2, req: { 'S': 1, 'O': 2 } },
            { id: 'sio2',    f: 'SiO₂',     name: 'Пісок',             vp: 10, count: 2, req: { 'Si': 1, 'O': 2 } },
            // Складні
            { id: 'caoh2',   f: 'Ca(OH)₂',  name: 'Гашене вапно',      vp: 7, count: 2, req: { 'Ca': 1, 'O': 2, 'H': 2 } },
            { id: 'h2so4',   f: 'H₂SO₄',    name: 'Сульфатна кислота', vp: 12, count: 1, req: { 'H': 2, 'S': 1, 'O': 4 } },
            { id: 'caco3',   f: 'CaCO₃',    name: 'Крейда',            vp: 9, count: 3, req: { 'Ca': 1, 'C': 1, 'O': 3 } },
            { id: 'nahco3',  f: 'NaHCO₃',   name: 'Харчова сода',      vp: 10, count: 3, req: { 'Na': 1, 'H': 1, 'C': 1, 'O': 3 } },
            { id: 'na2co3',  f: 'Na₂CO₃',   name: 'Кальцинована сода', vp: 12, count: 3, req: { 'Na': 2, 'C': 1, 'O': 3 } },
        ];

        const WINNING_SCORE = 50;

        // --- ДОПОМІЖНІ ФУНКЦІЇ ---
        const shuffleArray = (array) => {
            let arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        };

        const generateElementDeck = () => {
            let deck = [];
            Object.entries(ELEMENT_DISTRIBUTION).forEach(([el, count]) => {
                for (let i = 0; i < count; i++) deck.push(el);
            });
            return shuffleArray(deck);
        };

        const generateMoleculeDeck = () => {
            let deck = [];
            MOLECULES_LIST.forEach(mol => {
                for (let i = 0; i < (mol.count || 1); i++) {
                    deck.push({ ...mol, uniqueId: `${mol.id}_${i}_${Math.random().toString(36).substr(2, 5)}` });
                }
            });
            return shuffleArray(deck);
        };

        const checkRecipe = (hand, recipe) => {
            const handCounts = {};
            hand.forEach(el => handCounts[el] = (handCounts[el] || 0) + 1);
            for (const [el, needed] of Object.entries(recipe)) {
                if (!handCounts[el] || handCounts[el] < needed) return false;
            }
            return true;
        };

        const getAtomsList = (req) => {
            let list = [];
            Object.entries(req).forEach(([el, count]) => {
                for(let i=0; i<count; i++) list.push(el);
            });
            return list;
        };

        // --- КОМПОНЕНТИ ---

        const ElementCard = ({ type, count, mini = false, onClick, selected = false, style, overlap = false }) => {
            const data = ELEMENTS[type] || { m: '?', name: type, color: 'bg-gray-300' };
            
            if (mini) {
                return (
                    <div 
                        className={`
                        relative flex items-center justify-center w-10 h-12 rounded border shadow-sm select-none
                        ${data.color} ${selected ? 'ring-2 ring-blue-600 scale-110 z-10' : ''}
                        cursor-pointer transition-all
                        `}
                        onClick={onClick}
                    >
                        <span className="font-bold text-sm">{type}</span>
                    </div>
                );
            }

            return (
                <div 
                    onClick={onClick}
                    style={style}
                    className={`
                        relative w-20 h-32 sm:w-24 sm:h-36 rounded-xl shadow-md border-2 flex flex-col justify-between p-2 select-none transition-all duration-300 flex-shrink-0
                        ${data.color} ${selected ? 'ring-4 ring-blue-500 -translate-y-6 sm:-translate-y-8 z-30' : 'hover:-translate-y-2 sm:hover:-translate-y-4 hover:z-20'}
                        ${overlap ? '-ml-10 sm:-ml-12 hover:ml-1' : ''}
                        cursor-pointer bg-gradient-to-br from-white/60 to-transparent
                    `}
                >
                    <div className="flex justify-between items-start font-bold leading-none">
                        <span className="text-base sm:text-lg">{type}</span>
                        <span className="text-[10px] sm:text-xs opacity-60 pt-1">{data.m}</span>
                    </div>

                    <div className="flex flex-col items-center justify-center flex-grow">
                        <span className="text-3xl sm:text-4xl font-black font-serif opacity-90">{type}</span>
                        <span className="text-[0.5rem] sm:text-[0.6rem] uppercase tracking-wider opacity-70 mt-1 text-center leading-tight truncate w-full">{data.name}</span>
                    </div>

                    <div className="flex justify-between items-end font-bold leading-none rotate-180">
                        <span className="text-base sm:text-lg">{type}</span>
                        <span className="text-[10px] sm:text-xs opacity-60 pb-1">{data.m}</span>
                    </div>
                </div>
            );
        };

        const MoleculeCard = ({ mol, canBuy, onBuy }) => {
            return (
                <div className={`
                    relative w-[45%] sm:w-36 h-auto min-h-[160px] sm:min-h-[180px] bg-[#fffdf5] rounded-xl border-2 border-[#006400] shadow-lg flex flex-col
                    ${canBuy ? 'ring-4 ring-green-400 cursor-pointer hover:scale-105' : 'opacity-100'}
                    transition-all mb-2
                `} onClick={() => canBuy && onBuy(mol)}>
                    <div className="absolute top-0 right-0 bg-[#006400] text-white text-[10px] sm:text-xs px-2 py-1 rounded-bl-lg font-bold">
                        {mol.vp} VP
                    </div>
                    <div className="p-2 sm:p-3 text-center border-b border-[#006400]/20 mt-2">
                        <div className="text-xl sm:text-2xl font-bold text-gray-800 font-serif leading-tight">{mol.f}</div>
                        <div className="text-[0.6rem] sm:text-[0.7rem] uppercase text-gray-600 mt-1 font-bold line-clamp-2 min-h-[1.5em]">{mol.name}</div>
                    </div>
                    
                    {/* Визуалізація атомів кружечками */}
                    <div className="p-2 flex flex-wrap justify-center gap-1 bg-gradient-to-b from-transparent to-[#fceeb5]/30 flex-grow content-center">
                        {getAtomsList(mol.req).map((el, i) => (
                            <div key={i} className={`
                                w-5 h-5 sm:w-6 sm:h-6 rounded-full border border-black/20 shadow-sm flex items-center justify-center text-[0.6rem] sm:text-[0.65rem] font-bold
                                ${ELEMENTS[el]?.color || 'bg-gray-200'}
                            `}>
                                {el}
                            </div>
                        ))}
                    </div>

                    {canBuy && (
                        <div className="absolute inset-0 bg-green-500/20 flex items-center justify-center rounded-xl opacity-0 hover:opacity-100 transition-opacity backdrop-blur-[1px]">
                            <span className="bg-green-600 text-white px-3 py-1 sm:px-4 sm:py-2 rounded-full shadow-lg font-bold text-xs sm:text-sm transform scale-105">Синтез</span>
                        </div>
                    )}
                </div>
            );
        };

        const ElementSelectorModal = ({ isOpen, onClose, onSelect, title }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 bg-black/60 z-[60] flex items-center justify-center p-4 backdrop-blur-sm">
                    <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-4 sm:p-6 animate-in fade-in zoom-in duration-200">
                        <div className="flex justify-between items-center mb-4">
                        <h3 className="text-lg sm:text-xl font-bold text-gray-800">{title}</h3>
                        <button onClick={onClose} className="p-2 hover:bg-gray-100 rounded-full bg-gray-50"><X size={20}/></button>
                        </div>
                        <div className="grid grid-cols-4 gap-2 sm:gap-3 max-h-[60vh] overflow-y-auto p-1">
                        {Object.keys(ELEMENTS).map(el => (
                            <div key={el} onClick={() => onSelect(el)} className="cursor-pointer hover:scale-105 transition-transform flex justify-center">
                            <ElementCard type={el} mini />
                            </div>
                        ))}
                        </div>
                    </div>
                </div>
            );
        };

        // --- ГОЛОВНИЙ КОМПОНЕНТ ---

        const SynthesisGame = () => {
            const [user, setUser] = useState(null);
            const [gameId, setGameId] = useState('');
            const [gameData, setGameData] = useState(null);
            const [loading, setLoading] = useState(false);
            
            const [selectedCards, setSelectedCards] = useState([]);
            const [notification, setNotification] = useState(null);
            const [playerName, setPlayerName] = useState('');
            const [targetGameId, setTargetGameId] = useState('');

            const [is3to1ModalOpen, set3to1ModalOpen] = useState(false);
            const [tradeMode, setTradeMode] = useState(false);
            const [tradeStep, setTradeStep] = useState(0); 
            const [tradeOffer, setTradeOffer] = useState({ giveIdx: null, wantEl: null, targetUid: null });

            // Auth
            useEffect(() => {
                if (!auth) return;
                const initAuth = async () => {
                    try {
                        await signInAnonymously(auth);
                    } catch (error) {
                        console.error("Auth error:", error);
                        setNotification({ type: 'error', msg: "Помилка автентифікації." });
                    }
                };
                initAuth();
                return onAuthStateChanged(auth, u => setUser(u));
            }, []);

            // Sync
            useEffect(() => {
                if (!gameId || !user || !db) return;
                const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
                const unsubscribe = onSnapshot(gameRef, (snap) => {
                    if (snap.exists()) {
                        setGameData(snap.data());
                    } else {
                        setNotification({ type: 'error', msg: 'Кімнату не знайдено' });
                        setGameId('');
                    }
                }, (err) => {
                    console.error("Snapshot error:", err);
                    if (err.code === 'permission-denied') {
                         setNotification({ type: 'error', msg: 'Помилка доступу до БД. Перевірте Rules!' });
                    }
                });
                return () => unsubscribe();
            }, [gameId, user]);

            const myIndex = gameData?.players.findIndex(p => p.uid === user?.uid) ?? -1;
            const myPlayer = myIndex !== -1 ? gameData.players[myIndex] : null;
            const isMyTurn = gameData?.status === 'playing' && gameData?.turnIndex === myIndex;
            const isHost = gameData?.players[0].uid === user?.uid;
            
            // Check if user needs to discard
            const isDiscardPhase = gameData?.turnPhase === 'discard_force' && isMyTurn;
            const cardsToDiscard = isDiscardPhase ? Math.floor(myPlayer.hand.length / 2) : 0;

            const sortedHandMap = useMemo(() => {
                if (!myPlayer) return [];
                return myPlayer.hand
                    .map((card, originalIdx) => ({ card, originalIdx }))
                    .sort((a, b) => {
                        if (a.card === b.card) return a.originalIdx - b.originalIdx;
                        return a.card.localeCompare(b.card);
                    });
            }, [myPlayer?.hand]);

            // --- ДІЇ ---

            const createGame = async () => {
                if (!user || !db) return;
                if (!playerName.trim()) { setNotification({type:'error', msg:'Введіть ім\'я!'}); return; }
                setLoading(true);
                const newGameId = Math.random().toString(36).substring(2, 8).toUpperCase();
                
                const molDeck = generateMoleculeDeck();
                const initialMarket = molDeck.splice(0, 4); 

                const initialData = {
                    id: newGameId,
                    status: 'waiting', 
                    players: [{
                        uid: user.uid,
                        name: playerName,
                        hand: [],
                        score: 0,
                        molecules: []
                    }],
                    elementDeck: generateElementDeck(),
                    moleculeDeck: molDeck,
                    market: initialMarket,
                    discardPile: [], 
                    turnIndex: 0,
                    logs: [{ text: `Гру створено гравцем ${playerName}`, time: Date.now() }],
                    turnPhase: 'draw', 
                    activeTrade: null 
                };
                try {
                    await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'games', newGameId), initialData);
                    setGameId(newGameId);
                } catch (e) {
                    console.error(e);
                    setNotification({type:'error', msg: 'Помилка створення (див. консоль)'});
                }
                setLoading(false);
            };

            const joinGame = async (code) => {
                if (!user || !code || !db) return;
                if (!playerName.trim()) { setNotification({type:'error', msg:'Введіть ім\'я!'}); return; }
                setLoading(true);
                const codeUpper = code.toUpperCase().trim();
                const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', codeUpper);
                try {
                    await runTransaction(db, async (transaction) => {
                        const sfDoc = await transaction.get(gameRef);
                        if (!sfDoc.exists()) throw "Кімнати не існує";
                        const data = sfDoc.data();
                        if (data.status !== 'waiting' && !data.players.some(p => p.uid === user.uid)) throw "Гра вже почалась";
                        if (data.players.some(p => p.uid === user.uid)) return;
                        if (data.players.length >= 4) throw "Кімната переповнена";

                        const newPlayer = { uid: user.uid, name: playerName, hand: [], score: 0, molecules: [] };
                        transaction.update(gameRef, {
                            players: arrayUnion(newPlayer),
                            logs: arrayUnion({ text: `${playerName} приєднався`, time: Date.now() })
                        });
                    });
                    setGameId(codeUpper);
                } catch (e) {
                    setNotification({ type: 'error', msg: e.toString() });
                }
                setLoading(false);
            };

            const startGame = async () => {
                if (!gameData || !db) return;
                const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
                const newDeck = [...gameData.elementDeck];
                const updatedPlayers = gameData.players.map(p => ({ ...p, hand: newDeck.splice(0, 5) }));
                await updateDoc(gameRef, {
                    status: 'playing', elementDeck: newDeck, players: updatedPlayers, turnPhase: 'draw',
                    logs: arrayUnion({ text: 'Гра почалася! Роздано по 5 карт.', time: Date.now() })
                });
            };

            const drawCards = async (count = 2) => {
                if (!gameData || !isMyTurn || gameData.turnPhase !== 'draw') return;
                const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
                
                let newDeck = [...gameData.elementDeck];
                if (newDeck.length < count) {
                     setNotification({ type: 'error', msg: 'Колода елементів закінчилась!' });
                     // Можна додати логіку перетасування скиду, якщо треба
                     if (newDeck.length === 0) return; 
                }

                const drawn = newDeck.splice(0, Math.min(count, newDeck.length));
                const updatedPlayers = [...gameData.players];
                const newHand = [...myPlayer.hand, ...drawn];
                updatedPlayers[myIndex].hand = newHand;
                
                // Check for hand limit
                let nextPhase = 'action';
                let logMsg = `${myPlayer.name} взяв карти`;
                
                if (newHand.length > 10) {
                    nextPhase = 'discard_force';
                    logMsg += `. Перевантаження! Потрібно скинути карти.`;
                }

                await updateDoc(gameRef, {
                    elementDeck: newDeck,
                    players: updatedPlayers,
                    turnPhase: nextPhase,
                    logs: arrayUnion({ text: logMsg, time: Date.now() })
                });
            };

            const forceDiscardAction = async () => {
                if (selectedCards.length !== cardsToDiscard) {
                    setNotification({type: 'error', msg: `Оберіть рівно ${cardsToDiscard} карт`});
                    return;
                }
                const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
                let newHand = [...myPlayer.hand];
                // Remove selected
                selectedCards.sort((a,b) => b-a).forEach(idx => {
                    newHand.splice(idx, 1);
                });
                
                const updatedPlayers = [...gameData.players];
                updatedPlayers[myIndex].hand = newHand;

                await updateDoc(gameRef, {
                    players: updatedPlayers,
                    turnPhase: 'action', // Return to action phase
                    logs: arrayUnion({ text: `${myPlayer.name} скинув зайві карти`, time: Date.now() })
                });
                setSelectedCards([]);
            };

            const synthesize = async (molecule) => {
                if (!gameData || !isMyTurn || gameData.turnPhase !== 'action') return;
                const player = gameData.players[myIndex];
                
                const marketIndex = gameData.market.findIndex(m => m.uniqueId === molecule.uniqueId);
                if (marketIndex === -1) {
                    setNotification({type:'error', msg: "Цю картку вже хтось забрав!"});
                    return;
                }

                if (!checkRecipe(player.hand, molecule.req)) return;

                let newHand = [...player.hand];
                // Remove used atoms
                Object.entries(molecule.req).forEach(([el, count]) => {
                    for(let i=0; i<count; i++) {
                        const idx = newHand.indexOf(el);
                        if (idx > -1) {
                            newHand.splice(idx, 1);
                        }
                    }
                });

                const updatedPlayers = [...gameData.players];
                updatedPlayers[myIndex] = {
                    ...player,
                    hand: newHand,
                    molecules: [...player.molecules, molecule.id],
                    score: player.score + molecule.vp
                };

                const newMarket = [...gameData.market];
                const newMoleculeDeck = [...gameData.moleculeDeck];
                newMarket.splice(marketIndex, 1);
                if (newMoleculeDeck.length > 0) {
                    newMarket.push(newMoleculeDeck.shift());
                }

                let status = updatedPlayers[myIndex].score >= WINNING_SCORE ? 'finished' : 'playing';

                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId), {
                    players: updatedPlayers,
                    status,
                    market: newMarket,
                    moleculeDeck: newMoleculeDeck,
                    logs: arrayUnion({ text: `${player.name} синтезував ${molecule.name} (+${molecule.vp} VP)`, time: Date.now() })
                });
            };

            const passTurn = async () => {
                if (!gameData || !isMyTurn) return;
                const nextIndex = (gameData.turnIndex + 1) % gameData.players.length;
                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId), {
                    turnIndex: nextIndex,
                    turnPhase: 'draw',
                    logs: arrayUnion({ text: `Хід переходить до ${gameData.players[nextIndex].name}`, time: Date.now() })
                });
            };

            // Торгівля 3 до 1 (З банком)
            const confirmTrade3to1 = async (wantedElement) => {
                if (!tradeOffer.giveIdx && tradeOffer.giveIdx !== 0) return; 
                // tradeOffer.giveIdx - це індекс елемента, якого ми віддаємо 3 штуки
                // Тут логіка трохи спрощена для UI. Припустимо, ми вибрали 3 однакові карти.
                // В даній реалізації краще зробити перевірку:
                
                // Це вимагає складнішого UI вибору. 
                // Для спрощення: Реалізуємо "Скинути 3 будь-яких однакових -> Отримати 1 будь-який"
                // Але в UI ми поки це не реалізували повністю. 
                // Залишимо заглушку або просту реалізацію:
                set3to1ModalOpen(false);
                setNotification({type: 'success', msg: `Обмін виконано (тест)`});
            };

            // Обробка кліку на карту в руці
            const handleCardClick = (idx) => {
                if (isDiscardPhase) {
                    setSelectedCards(prev => prev.includes(idx) ? prev.filter(i => i !== idx) : [...prev, idx]);
                }
            };

            // --- UI RENDER ---

            if (loading) return <div className="h-screen flex items-center justify-center"><Loader2 className="animate-spin text-blue-600" size={48}/></div>;

            if (!gameData) {
                // ЛОББІ
                return (
                    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center p-4">
                        <div className="bg-white p-8 rounded-2xl shadow-xl w-full max-w-md space-y-6">
                            <div className="text-center">
                                <h1 className="text-4xl font-black text-blue-900 tracking-tighter mb-2">СИНТЕЗ</h1>
                                <p className="text-gray-500">Хімічна MMO-стратегія</p>
                            </div>
                            
                            <div className="space-y-4">
                                <input 
                                    type="text" 
                                    placeholder="Ваше ім'я" 
                                    className="w-full p-4 bg-gray-50 border-2 border-gray-200 rounded-xl focus:border-blue-500 focus:outline-none transition-colors font-bold text-lg"
                                    value={playerName}
                                    onChange={e => setPlayerName(e.target.value)}
                                />
                                
                                <button 
                                    onClick={createGame}
                                    className="w-full bg-blue-600 hover:bg-blue-700 text-white p-4 rounded-xl font-bold text-lg shadow-lg hover:shadow-blue-500/30 transition-all flex items-center justify-center gap-2"
                                >
                                    <FlaskConical /> Створити гру
                                </button>
                                
                                <div className="relative">
                                    <div className="absolute inset-0 flex items-center"><div className="w-full border-t border-gray-200"></div></div>
                                    <div className="relative flex justify-center text-sm"><span className="px-2 bg-white text-gray-500">або приєднатись</span></div>
                                </div>

                                <div className="flex gap-2">
                                    <input 
                                        type="text" 
                                        placeholder="Код кімнати" 
                                        className="flex-1 p-4 bg-gray-50 border-2 border-gray-200 rounded-xl font-mono text-center uppercase tracking-widest font-bold focus:border-blue-500 outline-none"
                                        value={targetGameId}
                                        onChange={e => setTargetGameId(e.target.value)}
                                    />
                                    <button 
                                        onClick={() => joinGame(targetGameId)}
                                        className="bg-gray-800 hover:bg-gray-900 text-white px-6 rounded-xl font-bold shadow-lg transition-all"
                                    >
                                        <ArrowRightLeft />
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            }

            if (gameData.status === 'waiting') {
                // КІМНАТА ОЧІКУВАННЯ
                return (
                    <div className="min-h-screen bg-blue-50 flex flex-col items-center justify-center p-4">
                        <div className="bg-white p-8 rounded-2xl shadow-xl w-full max-w-lg text-center">
                            <h2 className="text-2xl font-bold mb-2">Кімната: <span className="font-mono text-blue-600 text-4xl block mt-2 tracking-widest bg-blue-50 py-2 rounded-lg border-2 border-blue-100 border-dashed">{gameId}</span></h2>
                            <p className="text-gray-500 mb-6">Поділіться кодом з друзями</p>
                            
                            <div className="space-y-3 mb-8">
                                {gameData.players.map((p, i) => (
                                    <div key={i} className="flex items-center gap-3 p-3 bg-gray-50 rounded-xl border border-gray-100">
                                        <div className="w-10 h-10 bg-gradient-to-br from-blue-400 to-indigo-500 rounded-full flex items-center justify-center text-white font-bold shadow-md">
                                            {p.name[0]}
                                        </div>
                                        <span className="font-bold text-lg text-gray-700">{p.name}</span>
                                        {i === 0 && <Crown size={16} className="text-yellow-500 ml-auto" />}
                                    </div>
                                ))}
                                {[...Array(4 - gameData.players.length)].map((_, i) => (
                                    <div key={i} className="p-3 border-2 border-dashed border-gray-200 rounded-xl text-gray-300 font-bold flex items-center justify-center gap-2">
                                        <Loader2 className="animate-spin" size={16}/> Очікування...
                                    </div>
                                ))}
                            </div>

                            {isHost ? (
                                <button onClick={startGame} className="w-full bg-green-500 hover:bg-green-600 text-white py-4 rounded-xl font-bold text-xl shadow-lg hover:shadow-green-500/30 transition-all">
                                    Почати гру
                                </button>
                            ) : (
                                <div className="text-blue-600 animate-pulse font-bold">Очікуємо запуску гри організатором...</div>
                            )}
                        </div>
                    </div>
                );
            }

            // ГРА
            return (
                <div className="h-screen flex flex-col bg-slate-100 overflow-hidden relative">
                    {/* TOP BAR */}
                    <header className="bg-white shadow-sm px-4 py-2 flex justify-between items-center z-50">
                        <div className="flex items-center gap-2">
                            <div className="bg-blue-600 text-white w-8 h-8 rounded-lg flex items-center justify-center font-bold">{myPlayer?.score}</div>
                            <div className="leading-tight">
                                <div className="font-bold text-gray-800">{myPlayer?.name}</div>
                                <div className="text-xs text-gray-500">{myPlayer?.molecules.length} синтезовано</div>
                            </div>
                        </div>
                        
                        <div className="flex flex-col items-center">
                            <div className="font-black text-lg tracking-widest text-blue-900">СИНТЕЗ</div>
                            <div className={`text-xs px-2 py-0.5 rounded-full font-bold ${isMyTurn ? 'bg-green-100 text-green-700 animate-pulse' : 'bg-gray-100 text-gray-500'}`}>
                                {isMyTurn ? 'ВАШ ХІД' : `Хід: ${gameData.players[gameData.turnIndex].name}`}
                            </div>
                        </div>

                        <button onClick={() => setGameId('')} className="p-2 hover:bg-red-50 text-red-500 rounded-lg"><LogOut size={20}/></button>
                    </header>

                    {/* MAIN AREA */}
                    <div className="flex-1 overflow-y-auto p-4 pb-40">
                        {/* Market */}
                        <div className="mb-6">
                            <div className="flex justify-between items-center mb-2 px-1">
                                <h3 className="text-xs font-bold uppercase text-gray-400 tracking-wider">Ринок молекул ({gameData.moleculeDeck.length})</h3>
                                <div className="text-xs font-bold text-gray-400">Ціль: {WINNING_SCORE} VP</div>
                            </div>
                            <div className="flex flex-wrap gap-2 justify-center">
                                {gameData.market.map(mol => (
                                    <MoleculeCard 
                                        key={mol.uniqueId} 
                                        mol={mol} 
                                        canBuy={isMyTurn && gameData.turnPhase === 'action' && checkRecipe(myPlayer.hand, mol.req)}
                                        onBuy={synthesize}
                                    />
                                ))}
                            </div>
                        </div>

                        {/* Logs / Info */}
                        <div className="bg-white/50 rounded-xl p-3 text-xs text-gray-500 max-h-32 overflow-y-auto mb-4 border border-white">
                            {gameData.logs.slice(-5).reverse().map((l, i) => (
                                <div key={i} className="mb-1">
                                    <span className="opacity-50">{new Date(l.time).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}</span> {l.text}
                                </div>
                            ))}
                        </div>
                    </div>

                    {/* HAND (BOTTOM) */}
                    <footer className="absolute bottom-0 left-0 w-full bg-white shadow-[0_-4px_20px_rgba(0,0,0,0.1)] rounded-t-3xl z-40 transition-transform duration-300">
                        <div className="p-3">
                            <div className="flex justify-between items-end mb-2 px-2">
                                <div className="text-xs font-bold text-gray-400 uppercase tracking-wider">
                                    Ваша рука ({myPlayer?.hand.length}/10)
                                    {isDiscardPhase && <span className="text-red-500 ml-2 animate-pulse">Скиньте {cardsToDiscard - selectedCards.length}</span>}
                                </div>
                                
                                {isMyTurn && (
                                    <div className="flex gap-2">
                                        {gameData.turnPhase === 'draw' && (
                                            <button onClick={() => drawCards(2)} className="bg-blue-600 text-white px-4 py-2 rounded-full font-bold shadow-lg hover:bg-blue-700 active:scale-95 transition-all flex items-center gap-2">
                                                <History size={16}/> Взяти 2
                                            </button>
                                        )}
                                        {gameData.turnPhase === 'action' && (
                                            <button onClick={passTurn} className="bg-gray-800 text-white px-6 py-2 rounded-full font-bold shadow-lg hover:bg-gray-900 active:scale-95 transition-all">
                                                Завершити хід
                                            </button>
                                        )}
                                         {isDiscardPhase && (
                                            <button 
                                                onClick={forceDiscardAction}
                                                disabled={selectedCards.length !== cardsToDiscard}
                                                className={`px-6 py-2 rounded-full font-bold shadow-lg transition-all flex items-center gap-2
                                                ${selectedCards.length === cardsToDiscard ? 'bg-red-500 text-white hover:bg-red-600' : 'bg-gray-200 text-gray-400 cursor-not-allowed'}`}
                                            >
                                                <Trash2 size={16}/> Скинути
                                            </button>
                                        )}
                                    </div>
                                )}
                            </div>

                        {!isDiscardPhase ? (
                            <div className="flex overflow-x-auto pb-4 pt-8 px-4 gap-0 scrollbar-hide -mx-4 mask-linear-gradient" style={{ minHeight: '160px' }}>
                                {sortedHandMap.map(({ card, originalIdx }, i) => (
                                    <ElementCard 
                                        key={i} 
                                        type={card} 
                                        overlap={i > 0} 
                                        style={{ zIndex: i }}
                                        onClick={() => handleCardClick(originalIdx)}
                                    />
                                ))}
                            </div>
                        ) : (
                             <div className="grid grid-cols-5 gap-2 pb-4">
                                {myPlayer.hand.map((card, idx) => (
                                     <button 
                                        key={idx}
                                        onClick={() => handleCardClick(idx)}
                                        className={`p-2 rounded-lg border-2 font-bold text-sm transition-all
                                        ${selectedCards.includes(idx) ? 'bg-red-100 border-red-500 text-red-700 scale-95' : 'bg-gray-50 border-gray-200'}`}
                                     >
                                        {card}
                                     </button>
                                ))}
                            </div>
                        ) : (
                            <div className="text-center text-red-500 font-bold text-sm pb-3 animate-pulse">Оберіть карти для скидання, щоб продовжити гру!</div>
                        )}
                        </div>
                    </footer>
                    
                    {/* MODALS */}
                    <ElementSelectorModal isOpen={is3to1ModalOpen} onClose={() => set3to1ModalOpen(false)} onSelect={confirmTrade3to1} title="Отримайте ресурс" />
                    <ElementSelectorModal isOpen={tradeMode && tradeStep === 1} onClose={() => setTradeMode(false)} onSelect={() => {}} title="Що ви хочете отримати?" />

                    {notification && (
                        <div className={`fixed top-16 sm:top-24 left-1/2 -translate-x-1/2 px-4 sm:px-6 py-2 sm:py-3 rounded-xl shadow-2xl text-white font-bold z-[100] animate-in slide-in-from-top-4 text-xs sm:text-sm whitespace-nowrap ${notification.type==='error'?'bg-red-500':'bg-green-600'}`}>
                            {notification.msg}
                            {setTimeout(()=>setNotification(null), 3000) && ""}
                        </div>
                    )}
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<SynthesisGame />);
    </script>
</body>
</html>
