<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>СИНТЕЗ - Хімічна Стратегія</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            background-color: #f3f4f6;
        }
        #error-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.95); z-index: 9999; padding: 20px;
            overflow: auto; color: red; font-family: monospace; font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="error-overlay">
        <h2 style="color: black; font-weight: bold;">⚠️ Сталася помилка:</h2>
        <pre id="error-msg"></pre>
        <p style="color: black; margin-top: 20px;">Спробуйте оновити сторінку або надішліть фото цієї помилки.</p>
    </div>

    <div id="root"></div>

    <script>
        window.onerror = function(msg, url, line, col, error) {
            document.getElementById('error-overlay').style.display = 'block';
            document.getElementById('error-msg').innerText = 
                `Error: ${msg}\nLine: ${line}\nCol: ${col}\nStack: ${error ? error.stack : 'No stack'}`;
            return false;
        };
        // Перехоплення помилок промісів (async/await)
        window.onunhandledrejection = function(event) {
            document.getElementById('error-overlay').style.display = 'block';
            document.getElementById('error-msg').innerText += 
                `\nUnhandled Promise Rejection: ${event.reason}`;
        };
    </script>

    <script type="text/babel" data-type="module">
        // Використовуємо esm.sh для всіх імпортів, щоб уникнути конфліктів модулів
        import React, { useState, useEffect, useMemo } from 'https://esm.sh/react@18.2.0';
        import { createRoot } from 'https://esm.sh/react-dom@18.2.0/client';
        
        // Імпорт іконок
        import { 
            Atom, FlaskConical, Users, Copy, Check, AlertTriangle, 
            ArrowRightLeft, Play, RotateCcw, Crown, LogOut, Loader2, X, RefreshCcw, History, Trash2
        } from 'https://esm.sh/lucide-react@0.263.1';

        // Імпорт Firebase через esm.sh для сумісності
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
        import { 
            getFirestore, collection, doc, setDoc, onSnapshot, updateDoc, 
            arrayUnion, runTransaction 
        } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";
        import { 
            getAuth, signInAnonymously, onAuthStateChanged 
        } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";

        // ==========================================
        // НАЛАШТУВАННЯ (ПЕРЕВІРТЕ ЩЕ РАЗ)
        // ==========================================
        const firebaseConfig = {
            apiKey: "AIzaSyAEownlzJ0AqrnAku7Cw208N2DRLQHdD6Y",
            authDomain: "synthesis-game-f9684.firebaseapp.com",
            projectId: "synthesis-game-f9684",
            storageBucket: "synthesis-game-f9684.firebasestorage.app",
            messagingSenderId: "257683012244",
            appId: "1:257683012244:web:c7aee7e27c929ceb5b9281"
        };

        let app, auth, db;
        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
        } catch (e) {
            throw new Error("Firebase Init Failed: " + e.message);
        }

        const appId = 'synthesis-game';
        const WINNING_SCORE = 50;

        // --- ДАНІ ГРИ ---
        const ELEMENT_DISTRIBUTION = {
            'H': 24, 'O': 34, 'C': 12, 'Na': 10, 'Cl': 7, 'Ca': 8, 'N': 7, 'S': 6, 'Si': 4
        };

        const ELEMENTS = {
            'H':  { m: 1,  name: 'Гідроген', color: 'bg-blue-100 text-blue-900 border-blue-300' },
            'O':  { m: 16, name: 'Оксиген',  color: 'bg-red-100 text-red-900 border-red-300' },
            'C':  { m: 12, name: 'Карбон',   color: 'bg-gray-200 text-gray-900 border-gray-400' },
            'N':  { m: 14, name: 'Нітроген', color: 'bg-indigo-100 text-indigo-900 border-indigo-300' },
            'Na': { m: 23, name: 'Натрій',   color: 'bg-purple-100 text-purple-900 border-purple-300' },
            'Cl': { m: 35.5, name: 'Хлор',   color: 'bg-green-100 text-green-900 border-green-300' },
            'Ca': { m: 40, name: 'Кальцій',  color: 'bg-orange-100 text-orange-900 border-orange-300' },
            'S':  { m: 32, name: 'Сульфур',  color: 'bg-yellow-100 text-yellow-900 border-yellow-400' },
            'Si': { m: 28, name: 'Силіцій',  color: 'bg-stone-200 text-stone-800 border-stone-400' },
        };

        const MOLECULES_LIST = [
            { id: 'h2o',     f: 'H₂O',      name: 'Вода',              vp: 3, count: 6, req: { 'H': 2, 'O': 1 } },
            { id: 'co',      f: 'CO',       name: 'Чадний газ',        vp: 4, count: 4, req: { 'C': 1, 'O': 1 } },
            { id: 'hcl',     f: 'HCl',      name: 'Хлоридна кислота',  vp: 6, count: 3, req: { 'H': 1, 'Cl': 1 } },
            { id: 'cao',     f: 'CaO',      name: 'Негашене вапно',    vp: 4, count: 3, req: { 'Ca': 1, 'O': 1 } },
            { id: 'co2',     f: 'CO₂',      name: 'Вуглекислий газ',   vp: 5, count: 5, req: { 'C': 1, 'O': 2 } },
            { id: 'nacl',    f: 'NaCl',     name: 'Кухонна сіль',      vp: 8, count: 4, req: { 'Na': 1, 'Cl': 1 } },
            { id: 'naoh',    f: 'NaOH',     name: 'Каустична сода',    vp: 5, count: 3, req: { 'Na': 1, 'O': 1, 'H': 1 } },
            { id: 'nh3',     f: 'NH₃',      name: 'Аміак',             vp: 8, count: 2, req: { 'N': 1, 'H': 3 } },
            { id: 'h2o2',    f: 'H₂O₂',     name: 'Перекис водню',     vp: 4, count: 2, req: { 'H': 2, 'O': 2 } },
            { id: 'so2',     f: 'SO₂',      name: 'Сірчистий газ',     vp: 4, count: 2, req: { 'S': 1, 'O': 2 } },
            { id: 'sio2',    f: 'SiO₂',     name: 'Пісок',             vp: 10, count: 2, req: { 'Si': 1, 'O': 2 } },
            { id: 'caoh2',   f: 'Ca(OH)₂',  name: 'Гашене вапно',      vp: 7, count: 2, req: { 'Ca': 1, 'O': 2, 'H': 2 } },
            { id: 'h2so4',   f: 'H₂SO₄',    name: 'Сульфатна кислота', vp: 12, count: 1, req: { 'H': 2, 'S': 1, 'O': 4 } },
            { id: 'caco3',   f: 'CaCO₃',    name: 'Крейда',            vp: 9, count: 3, req: { 'Ca': 1, 'C': 1, 'O': 3 } },
            { id: 'nahco3',  f: 'NaHCO₃',   name: 'Харчова сода',      vp: 10, count: 3, req: { 'Na': 1, 'H': 1, 'C': 1, 'O': 3 } },
            { id: 'na2co3',  f: 'Na₂CO₃',   name: 'Кальцинована сода', vp: 12, count: 3, req: { 'Na': 2, 'C': 1, 'O': 3 } },
        ];

        // --- ДОПОМІЖНІ ФУНКЦІЇ ---
        const shuffleArray = (array) => {
            let arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        };

        const generateElementDeck = () => {
            let deck = [];
            Object.entries(ELEMENT_DISTRIBUTION).forEach(([el, count]) => {
                for (let i = 0; i < count; i++) deck.push(el);
            });
            return shuffleArray(deck);
        };

        const generateMoleculeDeck = () => {
            let deck = [];
            MOLECULES_LIST.forEach(mol => {
                for (let i = 0; i < (mol.count || 1); i++) {
                    deck.push({ ...mol, uniqueId: `${mol.id}_${i}_${Math.random().toString(36).substr(2, 5)}` });
                }
            });
            return shuffleArray(deck);
        };

        const checkRecipe = (hand, recipe) => {
            const handCounts = {};
            hand.forEach(el => handCounts[el] = (handCounts[el] || 0) + 1);
            for (const [el, needed] of Object.entries(recipe)) {
                if (!handCounts[el] || handCounts[el] < needed) return false;
            }
            return true;
        };
        
        const getAtomsList = (req) => {
            let list = [];
            Object.entries(req).forEach(([el, count]) => {
                for(let i=0; i<count; i++) list.push(el);
            });
            return list;
        };

        // --- КОМПОНЕНТИ ---
        const ElementCard = ({ type, count, mini = false, onClick, selected = false, style, overlap = false }) => {
            const data = ELEMENTS[type] || { m: '?', name: type, color: 'bg-gray-300' };
            if (mini) {
                return (
                    <div onClick={onClick} className={`relative flex items-center justify-center w-10 h-12 rounded border shadow-sm select-none ${data.color} ${selected ? 'ring-2 ring-blue-600 scale-110 z-10' : ''} cursor-pointer transition-all`}>
                        <span className="font-bold text-sm">{type}</span>
                    </div>
                );
            }
            return (
                <div onClick={onClick} style={style} className={`relative w-20 h-32 sm:w-24 sm:h-36 rounded-xl shadow-md border-2 flex flex-col justify-between p-2 select-none transition-all duration-300 flex-shrink-0 ${data.color} ${selected ? 'ring-4 ring-blue-500 -translate-y-6 z-30' : 'hover:-translate-y-2 hover:z-20'} ${overlap ? '-ml-10 sm:-ml-12 hover:ml-1' : ''} cursor-pointer bg-gradient-to-br from-white/60 to-transparent`}>
                    <div className="flex justify-between items-start font-bold leading-none"><span className="text-lg">{type}</span><span className="text-xs opacity-60 pt-1">{data.m}</span></div>
                    <div className="flex flex-col items-center justify-center flex-grow"><span className="text-4xl font-black font-serif opacity-90">{type}</span><span className="text-[0.6rem] uppercase tracking-wider opacity-70 mt-1 text-center truncate w-full">{data.name}</span></div>
                    <div className="flex justify-between items-end font-bold leading-none rotate-180"><span className="text-lg">{type}</span><span className="text-xs opacity-60 pb-1">{data.m}</span></div>
                </div>
            );
        };

        const MoleculeCard = ({ mol, canBuy, onBuy }) => {
            return (
                <div className={`relative w-[45%] sm:w-36 min-h-[160px] bg-[#fffdf5] rounded-xl border-2 border-[#006400] shadow-lg flex flex-col ${canBuy ? 'ring-4 ring-green-400 cursor-pointer hover:scale-105' : 'opacity-100'} transition-all mb-2`} onClick={() => canBuy && onBuy(mol)}>
                    <div className="absolute top-0 right-0 bg-[#006400] text-white text-xs px-2 py-1 rounded-bl-lg font-bold">{mol.vp} VP</div>
                    <div className="p-2 text-center border-b border-[#006400]/20 mt-2">
                        <div className="text-xl font-bold text-gray-800 font-serif leading-tight">{mol.f}</div>
                        <div className="text-[0.7rem] uppercase text-gray-600 mt-1 font-bold line-clamp-2">{mol.name}</div>
                    </div>
                    <div className="p-2 flex flex-wrap justify-center gap-1 flex-grow content-center">
                        {getAtomsList(mol.req).map((el, i) => (
                            <div key={i} className={`w-5 h-5 rounded-full border border-black/20 shadow-sm flex items-center justify-center text-[0.6rem] font-bold ${ELEMENTS[el]?.color || 'bg-gray-200'}`}>{el}</div>
                        ))}
                    </div>
                    {canBuy && <div className="absolute inset-0 bg-green-500/20 flex items-center justify-center rounded-xl opacity-0 hover:opacity-100 transition-opacity"><span className="bg-green-600 text-white px-3 py-1 rounded-full shadow-lg font-bold text-xs">Синтез</span></div>}
                </div>
            );
        };

        const ElementSelectorModal = ({ isOpen, onClose, onSelect, title }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 bg-black/60 z-[60] flex items-center justify-center p-4 backdrop-blur-sm">
                    <div className="bg-white rounded-xl shadow-2xl w-full max-w-lg p-6">
                        <div className="flex justify-between items-center mb-4">
                            <h3 className="text-xl font-bold">{title}</h3>
                            <button onClick={onClose}><X size={20}/></button>
                        </div>
                        <div className="grid grid-cols-4 gap-3">{Object.keys(ELEMENTS).map(el => (<div key={el} onClick={() => onSelect(el)} className="cursor-pointer flex justify-center"><ElementCard type={el} mini /></div>))}</div>
                    </div>
                </div>
            );
        };

        const SynthesisGame = () => {
            const [user, setUser] = useState(null);
            const [gameId, setGameId] = useState('');
            const [gameData, setGameData] = useState(null);
            const [loading, setLoading] = useState(false);
            const [selectedCards, setSelectedCards] = useState([]);
            const [notification, setNotification] = useState(null);
            const [playerName, setPlayerName] = useState('');
            const [targetGameId, setTargetGameId] = useState('');
            const [is3to1ModalOpen, set3to1ModalOpen] = useState(false);
            const [tradeMode, setTradeMode] = useState(false);

            useEffect(() => {
                const initAuth = async () => {
                    try {
                        await signInAnonymously(auth);
                    } catch (error) {
                        setNotification({ type: 'error', msg: "Помилка Auth: " + error.message });
                    }
                };
                initAuth();
                return onAuthStateChanged(auth, u => setUser(u));
            }, []);

            useEffect(() => {
                if (!gameId || !user || !db) return;
                const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
                const unsubscribe = onSnapshot(gameRef, (snap) => {
                    if (snap.exists()) setGameData(snap.data());
                    else { setNotification({ type: 'error', msg: 'Кімнату не знайдено' }); setGameId(''); }
                }, (err) => {
                    setNotification({ type: 'error', msg: 'Помилка БД: ' + err.code });
                });
                return () => unsubscribe();
            }, [gameId, user]);

            const myIndex = gameData?.players.findIndex(p => p.uid === user?.uid) ?? -1;
            const myPlayer = myIndex !== -1 ? gameData.players[myIndex] : null;
            const isMyTurn = gameData?.status === 'playing' && gameData?.turnIndex === myIndex;
            const isHost = gameData?.players[0].uid === user?.uid;
            const isDiscardPhase = gameData?.turnPhase === 'discard_force' && isMyTurn;
            const cardsToDiscard = isDiscardPhase ? Math.floor(myPlayer.hand.length / 2) : 0;

            const sortedHandMap = useMemo(() => {
                if (!myPlayer) return [];
                return myPlayer.hand.map((card, originalIdx) => ({ card, originalIdx })).sort((a, b) => {
                    if (a.card === b.card) return a.originalIdx - b.originalIdx;
                    return a.card.localeCompare(b.card);
                });
            }, [myPlayer?.hand]);

            const createGame = async () => {
                if (!playerName.trim()) return setNotification({type:'error', msg:'Введіть ім\'я!'});
                setLoading(true);
                const newGameId = Math.random().toString(36).substring(2, 8).toUpperCase();
                const molDeck = generateMoleculeDeck();
                const initialMarket = molDeck.splice(0, 4);
                const initialData = {
                    id: newGameId, status: 'waiting',
                    players: [{ uid: user.uid, name: playerName, hand: [], score: 0, molecules: [] }],
                    elementDeck: generateElementDeck(), moleculeDeck: molDeck, market: initialMarket,
                    discardPile: [], turnIndex: 0, logs: [{ text: `Гру створено: ${playerName}`, time: Date.now() }],
                    turnPhase: 'draw'
                };
                await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'games', newGameId), initialData);
                setGameId(newGameId);
                setLoading(false);
            };

            const joinGame = async (code) => {
                if (!playerName.trim()) return setNotification({type:'error', msg:'Введіть ім\'я!'});
                setLoading(true);
                const codeUpper = code.toUpperCase().trim();
                const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', codeUpper);
                await runTransaction(db, async (transaction) => {
                    const sfDoc = await transaction.get(gameRef);
                    if (!sfDoc.exists()) throw "Кімнати не існує";
                    const data = sfDoc.data();
                    if (data.players.some(p => p.uid === user.uid)) return;
                    if (data.status !== 'waiting') throw "Гра вже йде";
                    if (data.players.length >= 4) throw "Повно";
                    transaction.update(gameRef, {
                        players: arrayUnion({ uid: user.uid, name: playerName, hand: [], score: 0, molecules: [] }),
                        logs: arrayUnion({ text: `${playerName} зайшов`, time: Date.now() })
                    });
                });
                setGameId(codeUpper);
                setLoading(false);
            };

            const startGame = async () => {
                const newDeck = [...gameData.elementDeck];
                const updatedPlayers = gameData.players.map(p => ({ ...p, hand: newDeck.splice(0, 5) }));
                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId), {
                    status: 'playing', elementDeck: newDeck, players: updatedPlayers, turnPhase: 'draw',
                    logs: arrayUnion({ text: 'Старт!', time: Date.now() })
                });
            };

            const drawCards = async (count = 2) => {
                let newDeck = [...gameData.elementDeck];
                if (newDeck.length < count) { setNotification({type:'error', msg:'Колода пуста!'}); return; }
                const drawn = newDeck.splice(0, count);
                const updatedPlayers = [...gameData.players];
                const newHand = [...myPlayer.hand, ...drawn];
                updatedPlayers[myIndex].hand = newHand;
                let nextPhase = newHand.length > 10 ? 'discard_force' : 'action';
                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId), {
                    elementDeck: newDeck, players: updatedPlayers, turnPhase: nextPhase,
                    logs: arrayUnion({ text: `${myPlayer.name} взяв карти`, time: Date.now() })
                });
            };

            const forceDiscardAction = async () => {
                if (selectedCards.length !== cardsToDiscard) return setNotification({type:'error', msg:`Оберіть ${cardsToDiscard}`});
                let newHand = [...myPlayer.hand];
                selectedCards.sort((a,b)=>b-a).forEach(idx => newHand.splice(idx, 1));
                const updatedPlayers = [...gameData.players]; updatedPlayers[myIndex].hand = newHand;
                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId), {
                    players: updatedPlayers, turnPhase: 'action',
                    logs: arrayUnion({ text: `${myPlayer.name} скинув карти`, time: Date.now() })
                });
                setSelectedCards([]);
            };

            const synthesize = async (molecule) => {
                const player = gameData.players[myIndex];
                const marketIndex = gameData.market.findIndex(m => m.uniqueId === molecule.uniqueId);
                if (marketIndex === -1) return setNotification({type:'error', msg:"Вже забрали!"});
                if (!checkRecipe(player.hand, molecule.req)) return;
                
                let newHand = [...player.hand];
                Object.entries(molecule.req).forEach(([el, count]) => {
                    for(let i=0; i<count; i++) { const idx = newHand.indexOf(el); if(idx > -1) newHand.splice(idx, 1); }
                });
                const updatedPlayers = [...gameData.players];
                updatedPlayers[myIndex] = { ...player, hand: newHand, molecules: [...player.molecules, molecule.id], score: player.score + molecule.vp };
                const newMarket = [...gameData.market]; newMarket.splice(marketIndex, 1);
                const newMolDeck = [...gameData.moleculeDeck]; if(newMolDeck.length > 0) newMarket.push(newMolDeck.shift());
                const status = updatedPlayers[myIndex].score >= WINNING_SCORE ? 'finished' : 'playing';
                
                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId), {
                    players: updatedPlayers, status, market: newMarket, moleculeDeck: newMolDeck,
                    logs: arrayUnion({ text: `${player.name} +${molecule.vp}VP (${molecule.name})`, time: Date.now() })
                });
            };

            const passTurn = async () => {
                const nextIndex = (gameData.turnIndex + 1) % gameData.players.length;
                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId), {
                    turnIndex: nextIndex, turnPhase: 'draw',
                    logs: arrayUnion({ text: `Хід: ${gameData.players[nextIndex].name}`, time: Date.now() })
                });
            };

            const handleCardClick = (idx) => {
                if (isDiscardPhase) setSelectedCards(prev => prev.includes(idx) ? prev.filter(i => i !== idx) : [...prev, idx]);
            };

            if (loading) return <div className="h-screen flex items-center justify-center"><Loader2 className="animate-spin text-blue-600" size={48}/></div>;

            if (!gameData) {
                return (
                    <div className="min-h-screen bg-blue-50 flex items-center justify-center p-4">
                        <div className="bg-white p-8 rounded-2xl shadow-xl w-full max-w-md space-y-6">
                            <h1 className="text-4xl font-black text-center text-blue-900">СИНТЕЗ</h1>
                            <input type="text" placeholder="Ваше ім'я" className="w-full p-4 bg-gray-50 border-2 rounded-xl font-bold" value={playerName} onChange={e => setPlayerName(e.target.value)}/>
                            <button onClick={createGame} className="w-full bg-blue-600 text-white p-4 rounded-xl font-bold flex justify-center gap-2"><FlaskConical/> Створити гру</button>
                            <div className="flex gap-2"><input type="text" placeholder="Код" className="flex-1 p-4 bg-gray-50 border-2 rounded-xl font-bold text-center uppercase" value={targetGameId} onChange={e => setTargetGameId(e.target.value)}/><button onClick={() => joinGame(targetGameId)} className="bg-gray-800 text-white px-6 rounded-xl"><ArrowRightLeft/></button></div>
                        </div>
                    </div>
                );
            }

            if (gameData.status === 'waiting') {
                return (
                    <div className="min-h-screen bg-blue-50 flex flex-col items-center justify-center p-4">
                        <div className="bg-white p-6 rounded-xl shadow-xl w-full max-w-lg text-center">
                            <h2 className="text-2xl font-bold">Код: <span className="font-mono text-blue-600 text-4xl block my-2">{gameId}</span></h2>
                            <div className="space-y-2 mb-6">{gameData.players.map((p, i) => (<div key={i} className="p-3 bg-gray-50 rounded border font-bold flex items-center gap-2">{p.name} {i===0 && <Crown size={16} className="text-yellow-500"/>}</div>))}</div>
                            {isHost ? <button onClick={startGame} className="w-full bg-green-500 text-white py-4 rounded-xl font-bold text-xl">Почати</button> : <div className="animate-pulse font-bold text-blue-600">Очікування організатора...</div>}
                        </div>
                    </div>
                );
            }

            return (
                <div className="h-screen flex flex-col bg-slate-100 overflow-hidden relative">
                    <header className="bg-white shadow-sm px-4 py-2 flex justify-between items-center z-50">
                        <div className="flex items-center gap-2"><div className="bg-blue-600 text-white w-8 h-8 rounded-lg flex items-center justify-center font-bold">{myPlayer?.score}</div><div className="font-bold">{myPlayer?.name}</div></div>
                        <div className="flex flex-col items-center"><div className="font-black tracking-widest text-blue-900">СИНТЕЗ</div><div className={`text-xs px-2 rounded-full font-bold ${isMyTurn ? 'bg-green-100 text-green-700 animate-pulse' : 'bg-gray-100'}`}>{isMyTurn ? 'ВАШ ХІД' : `Хід: ${gameData.players[gameData.turnIndex].name}`}</div></div>
                        <button onClick={() => setGameId('')} className="p-2 text-red-500"><LogOut size={20}/></button>
                    </header>
                    <div className="flex-1 overflow-y-auto p-4 pb-40">
                        <div className="mb-6"><div className="text-xs font-bold text-gray-400 uppercase mb-2">Ринок</div><div className="flex flex-wrap gap-2 justify-center">{gameData.market.map(mol => (<MoleculeCard key={mol.uniqueId} mol={mol} canBuy={isMyTurn && gameData.turnPhase === 'action' && checkRecipe(myPlayer.hand, mol.req)} onBuy={synthesize}/>))}</div></div>
                        <div className="bg-white/50 rounded-xl p-3 text-xs text-gray-500 max-h-32 overflow-y-auto mb-4 border">{gameData.logs.slice(-5).reverse().map((l, i) => (<div key={i} className="mb-1"><span className="opacity-50">{new Date(l.time).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}</span> {l.text}</div>))}</div>
                    </div>
                    <footer className="absolute bottom-0 left-0 w-full bg-white shadow-[0_-4px_20px_rgba(0,0,0,0.1)] rounded-t-3xl z-40">
                        <div className="p-3">
                            <div className="flex justify-between items-end mb-2 px-2">
                                <div className="text-xs font-bold text-gray-400 uppercase">Рука ({myPlayer?.hand.length}/10)</div>
                                {isMyTurn && <div className="flex gap-2">
                                    {gameData.turnPhase === 'draw' && <button onClick={() => drawCards(2)} className="bg-blue-600 text-white px-4 py-2 rounded-full font-bold flex gap-2"><History size={16}/> Взяти 2</button>}
                                    {gameData.turnPhase === 'action' && <button onClick={passTurn} className="bg-gray-800 text-white px-6 py-2 rounded-full font-bold">Кінець ходу</button>}
                                    {isDiscardPhase && <button onClick={forceDiscardAction} disabled={selectedCards.length !== cardsToDiscard} className={`px-6 py-2 rounded-full font-bold flex gap-2 ${selectedCards.length === cardsToDiscard ? 'bg-red-500 text-white' : 'bg-gray-200'}`}><Trash2 size={16}/> Скинути</button>}
                                </div>}
                            </div>
                            {!isDiscardPhase ? (
                                <div className="flex overflow-x-auto pb-4 pt-8 px-4 gap-0 scrollbar-hide -mx-4 mask-linear-gradient" style={{ minHeight: '160px' }}>
                                    {sortedHandMap.map(({ card, originalIdx }, i) => (<ElementCard key={i} type={card} overlap={i > 0} style={{ zIndex: i }} onClick={() => handleCardClick(originalIdx)}/>))}
                                </div>
                            ) : (
                                <div className="grid grid-cols-5 gap-2 pb-4">{myPlayer.hand.map((card, idx) => (<button key={idx} onClick={() => handleCardClick(idx)} className={`p-2 rounded-lg border-2 font-bold text-sm ${selectedCards.includes(idx) ? 'bg-red-100 border-red-500' : 'bg-gray-50'}`}>{card}</button>))}</div>
                            )}
                        </div>
                    </footer>
                    <ElementSelectorModal isOpen={is3to1ModalOpen} onClose={() => set3to1ModalOpen(false)} onSelect={() => {}} title="Обмін" />
                    {notification && <div className={`fixed top-24 left-1/2 -translate-x-1/2 px-6 py-3 rounded-xl shadow-xl text-white font-bold z-[100] ${notification.type==='error'?'bg-red-500':'bg-green-600'}`}>{notification.msg}{setTimeout(()=>setNotification(null), 3000) && ""}</div>}
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<SynthesisGame />);
    </script>
</body>
</html>
